#!/usr/bin/env perl
#
use warnings;
use strict;
use Getopt::Long;

my $helpFlag = 0;
my $dbDir;
my $species = "Hsa";

GetOptions("help"     => \$helpFlag,
            "dbDir=s" => \$dbDir,
            "sp=s"    => \$species
);

if ($helpFlag) {
  print STDERR "Usage: $0 [options] combine_folder

OPTIONS:
  -dbDir DBDIR   : Database directory
  -sp Hsa/Mmu    : $species
  -h, --help     : Print this message
";
  exit 1;
}

my $combineFolder = $ARGV[0];

my @files1=glob($combineFolder . "/*.IR"); # This should take all the counts in the folder for "combine sample"
my @files2=glob($combineFolder . "/*.IR.gz"); # This should take all the counts in the folder for "combine sample"
my @files=(@files1,@files2);
my $N=$#files+1;

die "Error in $0: No samples found in folder $combineFolder\n" if ($N == 0);

### Loads the mappability. Any junctions that is not here, it's supposed to NOT HAVE mappability. This file was generated by Nuno.
my %mappability_ns;
my $mappabilityFile = $dbDir . "/FILES/$species.IntronJunctions.new.50.8.uniquecount.txt";
open (MAPPABILITY, "<$mappabilityFile") or die "File $mappabilityFile not found - $!\n";
while (<MAPPABILITY>){
    chomp;
    my @temp=split(/\t/);
    my ($event,$junction)=$temp[0]=~/(.+?\:.+?\:\d+)\-(E.+?)\:/;
    $mappability_ns{$event}{$junction}=$temp[1];
}
close MAPPABILITY;

my %mappability_ss;
$mappabilityFile = $dbDir . "/FILES/$species.IntronJunctions.new-SS.50.8.uniquecount.txt";
open (MAPPABILITY, "<$mappabilityFile") or die "File $mappabilityFile not found - $!\n";
while (<MAPPABILITY>){
    chomp;
    my @temp=split(/\t/);
    my ($event,$junction)=$temp[0]=~/(.+?\:.+?\:\d+)\-(E.+?)\:/;
    $mappability_ss{$event}{$junction}=$temp[1];
}
close MAPPABILITY;

### For each file with counts
my %samples;
my %corrected_reads;
my %raw_reads;
my $mappability_href;
foreach my $file (@files){
    my ($sample)=$file=~/([^\/]+)\.IR$/;
    $samples{$sample}=1;
    my $fname=$file;
    $fname =~ s/^.*\///;
#    (my $sample2)=$fname=~/^(.*)\.IR/;

    unless(-e "to_combine/$sample.info" || -e "to_combine/$sample.info.gz"){
    	print STDERR "[vast combine IR]: Do not find to_combine/${sample}.info. Sample $sample will be treated as being not strand-specific.";
    	$mappability_href=\%mappability_ns;
    }else{
	my $fh_info;
        if (-e "to_combine/$sample.info.gz"){
            open($fh_info, "gunzip -c to_combine/$sample.info.gz | ") or die "$!";
        } else {
            open($fh_info, "to_combine/$sample.info") or die "$!";
        }
	my $line=<$fh_info>; close($fh_info);
    	my @fs=split("\t",$line);
    	if($fs[@fs-2] eq "-SS"){
    		print STDERR "[vast combine IR]: Do not find to_combine/${sample}.info. Sample $sample will be treated as being strand-specific.";
    		$mappability_href=\%mappability_ss;
    	}else{
    		print STDERR "[vast combine IR]: Do not find to_combine/${sample}.info. Sample $sample will be treated as being not strand-specific.";
    		$mappability_href=\%mappability_ns;
    	}
    }

    ### opens file
    if ($file=~/\.gz$/){
	open (IN, "gunzip -c $file | ") || die"It cannot open the $file\n";
    } else {
        open (IN, $file);
    }
    <IN>;
    while (<IN>){ # Format:  Event_ID EIJ1 EIJ2 EEJ I
        chomp;
        my @temp=split(/\t/);

        ### The file has the corrected counts already
        $corrected_reads{$temp[0]}{'EI1'}{$sample}=$temp[1];
        $corrected_reads{$temp[0]}{'EI2'}{$sample}=$temp[2];
        $corrected_reads{$temp[0]}{'EE'}{$sample}=$temp[3];

        ### if we have the raw reads, this will be way easier
        $raw_reads{$temp[0]}{'EI1'}{$sample}=sprintf("%.0f",$temp[1]*$mappability_href->{$temp[0]}{'EI1'}/35) if $mappability_href->{$temp[0]}{'EI1'};
        $raw_reads{$temp[0]}{'EI1'}{$sample}="ne" if !$mappability_href->{$temp[0]}{'EI1'};
        $raw_reads{$temp[0]}{'EI2'}{$sample}=sprintf("%.0f",$temp[2]*$mappability_href->{$temp[0]}{'EI2'}/35) if $mappability_href->{$temp[0]}{'EI2'};
        $raw_reads{$temp[0]}{'EI2'}{$sample}="ne" if !$mappability_href->{$temp[0]}{'EI2'};
        $raw_reads{$temp[0]}{'EE'}{$sample}=sprintf("%.0f",$temp[3]*$mappability_href->{$temp[0]}{'EE'}/35) if $mappability_href->{$temp[0]}{'EE'};
        $raw_reads{$temp[0]}{'EE'}{$sample}="ne" if !$mappability_href->{$temp[0]}{'EE'};
    }
    close IN;
}

my $M = keys %samples;
if (! %samples or $M != $N) {
    die "Number of parsed samples ($M) does not match number of input samples
        ($N)";
}

my $outputFile = "$combineFolder/Coverage_key-$species$N.IRQ";
open (OUT, ">$outputFile") or die "Failed to open $outputFile";

print OUT "EVENT";
foreach my $sample (sort keys %samples){
    print OUT "\t$sample";
}
print OUT "\n";

foreach my $event (sort keys %mappability_ns){
    print OUT "$event";
    foreach my $sample (sort keys %samples){
        my $eEI=$corrected_reads{$event}{EI1}{$sample};
        my $eIE=$corrected_reads{$event}{EI2}{$sample};
        my $eEE=$corrected_reads{$event}{EE}{$sample};

        my $rEI=$raw_reads{$event}{EI1}{$sample};
        my $rIE=$raw_reads{$event}{EI2}{$sample};
        my $rEE=$raw_reads{$event}{EE}{$sample};

        $rEI=0 if !$raw_reads{$event}{EI1}{$sample};
        $rIE=0 if !$raw_reads{$event}{EI2}{$sample};
        $rEE=0 if !$raw_reads{$event}{EE}{$sample};

        my $reads="$rEI=$rIE=$rEE"; # string with the raw read counts for the three junctions

        my $Q;

        ### If any of the three junctions is "ne" (=no mappability) the whole KEY is turned into N's
        if ($rIE eq "ne" || $rEI eq "ne" || $rEE eq "ne") {
            $Q="N,N,NA,ne";  # score 3 set to NA for consistency --UB
        } else {
            ### Corresponds to Q1 in other events
            $Q="N";
            $Q="VLOW" if (($rEI>=5 && $rIE>=10) || ($rEI>=10 && $rIE>=5) || $rEE>=10);
            $Q="LOW" if (($rEI>=10 && $rIE>=15) || ($rEI>=15 && $rIE>=10) || $rEE>=15);
            $Q="OK" if (($rEI>=15 && $rIE>=20) || ($rEI>=20 && $rIE>=15) || $rEE>=20);
            $Q="SOK" if ((($rEI>=15 && $rIE>=20) || ($rEI>=20 && $rIE>=15) || $rEE>=20) && ($rEI+$rIE+$rEE)>=100);

            ### Includes keys 2,3 and 4 of other events, but only 2 is real. 3 is always
            ### "NA" and "Reads" is just all the reads.
            ### The 5th key would be Ulrich's imbalanced test p-value and will be added later
            if (! (defined $eEI && defined $eIE && defined $eEE)) {
                $Q.=",N,NA,$reads";
            }
            elsif ((($eEI>=15 && $eIE>=20) || ($eEI>=20 && $eIE>=15) || $eEE>=20) && ($eEI+$eIE+$eEE)>=100){
                $Q.=",SOK,NA,$reads";
            }
            elsif (($eEI>=15 && $eIE>=20) || ($eEI>=20 && $eIE>=15) || $eEE>=20){
                $Q.=",OK,NA,$reads";
            }
            elsif (($eEI>=10 && $eIE>=15) || ($eEI>=15 && $eIE>=10) || $eEE>=15){
                $Q.=",LOW,NA,$reads";
            }
            elsif (($eEI>=5 && $eIE>=10) || ($eEI>=10 && $eIE>=5) || $eEE>=10){
                $Q.=",VLOW,NA,$reads";
            }
            else {
                $Q.=",N,NA,$reads";
            }
        }
        print OUT "\t$Q";
    }
    print OUT "\n";
}
